<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jason&#39;s iOS Notes</title>
  <subtitle>默默的提升iOS开发水平</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jasoniosdev.github.io/"/>
  <updated>2016-08-24T10:25:26.000Z</updated>
  <id>https://jasoniosdev.github.io/</id>
  
  <author>
    <name>Jason</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SDWebImage浅读(一)</title>
    <link href="https://jasoniosdev.github.io/SDWebImageReadOne/"/>
    <id>https://jasoniosdev.github.io/SDWebImageReadOne/</id>
    <published>2016-08-22T09:01:13.000Z</published>
    <updated>2016-08-24T10:25:26.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="SDWebImage"><a href="#SDWebImage" class="headerlink" title="SDWebImage"></a>SDWebImage</h4><p>　　之前一直在打算看SDWebImage的源码，一方面是因为面试常问，一方面是这个库确实写的非常精妙。这次看稍微读了一下，由于可能自身水平比较有限，感觉这次只懂了20%，就大概懂用了哪些东西，顺序如何，其他的估计等自己水平上升了或者是开发中接触到了，再来挖掘吧。而且由于本人缺乏对应项目结构的经验，可能在措辞和总结上不是很规范，希望懂得同学能够指出我的错误，不吝赐教，谢谢。</p>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>　 SDWebImage类上主要包含<br>　　<code>SDWebImageManager</code>：以单例的形式负责整个类使用的调度，职责如同Manager这个单词一样。类里面有两个属性<code>SDImageCache</code>和<code>SDImageDownloader</code>，还有一个<code>SDWebImageCacheKeyFilterBlock</code>类型的cacheKeyFilter闭包，不过貌似这个闭包是可以根据用户的规则去生成，在库内并没有实现。<br>　　<code>SDImageCache</code>：负责图片的缓存操作，可以缓存在内存或者磁盘当中，可以强制选择不缓存在磁盘当中。利用对<code>NSCache</code>的简单封装,以此来管理图片的缓存。<br>　　<code>SDWebImageDownloader</code>：负责图片的下载服务，通过一个OperationQueue来管理DownloaderOperation，拥有实际的<code>NSURLSession</code>的一个对象。<br>　　<code>SDWebImageDownloaderOperation</code>：实际进行图片下载的服务，通过<code>NSURLSession</code>进行下载，<code>NSURLSession</code>的回调是来自<code>SDWebImageDownloader</code>。<br>　　<code>SDWebImageDecoder</code>：负责图片的解码，由于不是很懂图像处理，日后等了解了再来学习。<br>　　然后通过Category的形式来给每个类拓展功能。<br>　　其他的类还没怎么学习。</p>
<h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>　　<code>SDWebImage</code>可以方便的通过一个方法来加载图片，以<code>UIImageView</code>为例，其最终调用的方法都是<code>sd_setImageWithURL:placeholderImage:options:progress:completed:</code><br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock &#123;&#10;    //&#23558;&#24403;&#21069;&#25511;&#20214;&#30340;&#21152;&#36733;&#25805;&#20316;&#21462;&#28040;&#10;    [self sd_cancelCurrentImageLoad];&#10;    //&#26356;&#26032;&#24403;&#21069;&#25511;&#20214;&#30340;&#22270;&#29255;URL&#10;    objc_setAssociatedObject(self, &#38;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#10;    //&#26816;&#27979;&#19968;&#19979;&#26159;&#21542;&#35201;&#21152;&#21344;&#20301;&#22270;&#10;    if (!(options &#38; SDWebImageDelayPlaceholder)) &#123;&#10;        dispatch_main_async_safe(^&#123;&#10;            self.image = placeholder;&#10;        &#125;);&#10;    &#125;&#10;    &#10;    if (url) &#123;&#10;&#10;        //&#28155;&#21152;&#21152;&#36733;&#35270;&#22270;&#10;        if ([self showActivityIndicatorView]) &#123;&#10;            [self addActivityIndicator];&#10;        &#125;&#10;        &#10;        //&#35843;&#29992;Manager&#30340;&#21333;&#20363;&#36827;&#34892;&#22270;&#29255;&#19979;&#36733;&#10;        __weak __typeof(self)wself = self;&#10;        id &#60;SDWebImageOperation&#62; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123;&#10;            [wself removeActivityIndicator];&#10;            if (!wself) return;&#10;            dispatch_main_sync_safe(^&#123;&#10;                if (!wself) return;&#10;                &#10;                //&#22914;&#26524;&#29992;&#25143;&#38656;&#35201;&#33258;&#24049;&#35774;&#32622;&#22270;&#29255;&#30340;&#35805;&#65292;&#21017;&#30452;&#25509;&#35843;&#29992;&#22238;&#35843;&#65292;&#24182;&#36820;&#22238;&#10;                if (image &#38;&#38; (options &#38; SDWebImageAvoidAutoSetImage) &#38;&#38; completedBlock)&#10;                &#123;&#10;                    completedBlock(image, error, cacheType, url);&#10;                    return;&#10;                &#125;&#10;                else if (image) &#123;&#10;                    //&#33258;&#21160;&#23558;&#22270;&#29255;&#26174;&#31034;&#20986;&#26469;&#10;                    wself.image = image;&#10;                    [wself setNeedsLayout];&#10;                &#125; else &#123;&#10;                    //&#22914;&#26524;&#22270;&#29255;&#19979;&#36733;&#22833;&#36133;&#65292;&#21017;&#26816;&#26597;&#19968;&#19979;&#26159;&#21542;&#35201;&#25918;&#21344;&#20301;&#22270;&#10;                    if ((options &#38; SDWebImageDelayPlaceholder)) &#123;&#10;                        wself.image = placeholder;&#10;                        [wself setNeedsLayout];&#10;                    &#125;&#10;                &#125;&#10;                //&#32467;&#26463;&#22238;&#35843;&#10;                if (completedBlock &#38;&#38; finished) &#123;&#10;                    completedBlock(image, error, cacheType, url);&#10;                &#125;&#10;            &#125;);&#10;        &#125;];&#10;        //&#23558;&#25805;&#20316;&#21152;&#20837;&#21040;&#23383;&#20856;&#24403;&#20013;&#65292;&#32531;&#23384;&#36215;&#26469;&#10;        [self sd_setImageLoadOperation:operation forKey:@&#34;UIImageViewImageLoad&#34;];&#10;    &#125; else &#123;&#10;        //&#22914;&#26524;URL&#20026;&#31354;&#30340;&#35805;&#65292;&#21017;&#30452;&#25509;&#22238;&#35843;&#10;        dispatch_main_async_safe(^&#123;&#10;            [self removeActivityIndicator];&#10;            if (completedBlock) &#123;&#10;                NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:-1 userInfo:@&#123;NSLocalizedDescriptionKey : @&#34;Trying to load a nil url&#34;&#125;];&#10;                completedBlock(nil, error, SDImageCacheTypeNone, url);&#10;            &#125;&#10;        &#125;);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> [self sd_cancelCurrentImageLoad];&#10; &#36825;&#20010;&#26041;&#27861;&#36127;&#36131;&#23558;&#30446;&#21069;&#35813;&#25511;&#20214;&#27491;&#22312;&#36827;&#34892;&#30340;&#22270;&#29255;&#21152;&#36733;&#25805;&#20316;&#21462;&#28040;&#65292;&#20197;&#24320;&#22987;&#26032;&#30340;&#25805;&#20316;&#65292;&#27605;&#31455;&#37027;&#20123;&#25805;&#20316;&#24050;&#32463;&#36807;&#26399;&#20102;&#12290;&#10; - (void)sd_cancelImageLoadOperationWithKey:(NSString *)key &#123;&#10;    // Cancel in progress downloader from queue&#10;    NSMutableDictionary *operationDictionary = [self operationDictionary];&#10;    //operationDictionary&#26159;&#29992;&#20851;&#32852;&#21464;&#37327;&#22686;&#21152;&#30340;&#19968;&#20010;&#23384;&#20648;&#25805;&#20316;&#30340;&#23383;&#20856;&#10;    id operations = [operationDictionary objectForKey:key];&#10;    if (operations) &#123;&#10;        if ([operations isKindOfClass:[NSArray class]]) &#123;&#10;            for (id &#60;SDWebImageOperation&#62; operation in operations) &#123;&#10;                //SDWebImageOperation&#26159;&#19968;&#20010;&#21327;&#35758;&#65292;&#35813;&#21327;&#35758;&#21482;&#26377;&#19968;&#20010;&#26041;&#27861;-Cancel&#10;                //SD&#24403;&#20013;&#35768;&#22810;&#22320;&#26041;&#37117;&#29992;&#21040;&#20102;Operation&#65292;&#32780;&#19988;&#21462;&#28040;&#30340;&#25805;&#20316;&#20063;&#24456;&#24120;&#35265;&#10;                //&#22810;&#20010;Operation&#30340;&#24773;&#20917;&#25105;&#36824;&#27809;&#30475;&#21040;&#65292;&#19981;&#26159;&#24456;&#28165;&#26970;&#20160;&#20040;&#24773;&#20917;&#19979;&#20250;&#36827;&#36825;&#20010;&#24490;&#29615;&#10;                if (operation) &#123;&#10;                    [operation cancel];&#10;                &#125;&#10;            &#125;&#10;        &#125; else if ([operations conformsToProtocol:@protocol(SDWebImageOperation)])&#123;&#10;            [(id&#60;SDWebImageOperation&#62;) operations cancel];&#10;        &#125;&#10;        //&#21462;&#28040;&#23436;&#33258;&#28982;&#23601;&#25226;&#35813;&#25805;&#20316;&#31227;&#38500;&#20102;&#10;        [operationDictionary removeObjectForKey:key];&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SDWebImageManager"><a href="#SDWebImageManager" class="headerlink" title="SDWebImageManager"></a>SDWebImageManager</h4><p>下载的操作主要是由<code>SDWebImageManager</code>单例来负责完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id &#60;SDWebImageOperation&#62;)downloadImageWithURL:(NSURL *)url&#10;                                         options:(SDWebImageOptions)options&#10;                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock&#10;                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock &#123;&#10;    NSAssert(completedBlock != nil, @&#34;If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead&#34;);&#10;    //&#20197;&#19978;&#25805;&#20316;&#30830;&#20445;url&#26159;&#27491;&#30830;&#30340;&#65292;&#19981;&#27491;&#30830;&#30340;&#35805;&#20026;&#31354;&#65292;&#36339;&#36807;&#25805;&#20316;&#10;    if ([url isKindOfClass:NSString.class]) &#123;&#10;        url = [NSURL URLWithString:(NSString *)url];&#10;    &#125;&#10;    if (![url isKindOfClass:NSURL.class]) &#123;&#10;        url = nil;&#10;    &#125;&#10;    &#10;    //&#21033;&#29992;&#19968;&#20010;Operation&#26469;&#26041;&#20415;&#21518;&#32493;&#30340;&#21462;&#28040;&#25805;&#20316;&#65292;&#36991;&#20813;&#20570;&#22810;&#20313;&#37325;&#21472;&#30340;&#25805;&#20316;&#10;    __block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];&#10;    __weak SDWebImageCombinedOperation *weakOperation = operation;&#10;   &#10;    //&#21028;&#26029;&#19968;&#19979;&#65292;&#38142;&#25509;&#26159;&#21542;&#26159;&#26080;&#25928;&#30340;&#38142;&#25509;&#10;    BOOL isFailedUrl = NO;&#10;    @synchronized (self.failedURLs) &#123;&#10;        isFailedUrl = [self.failedURLs containsObject:url];&#10;    &#125;&#10;&#10;    if (url.absoluteString.length == 0 || (!(options &#38; SDWebImageRetryFailed) &#38;&#38; isFailedUrl)) &#123;&#10;        dispatch_main_sync_safe(^&#123;&#10;            NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];&#10;            completedBlock(nil, error, SDImageCacheTypeNone, YES, url);&#10;        &#125;);&#10;        return operation;&#10;    &#125;&#10;&#10;    //&#36825;&#20010;Array&#19981;&#30693;&#36947;&#26377;&#20160;&#20040;&#29992;&#65311;&#29992;&#20110;&#21462;&#28040;&#25152;&#26377;&#25805;&#20316;&#65311;&#21518;&#26469;&#24819;&#21040;&#19968;&#20010;&#20316;&#29992;&#26159;&#25345;&#26377;Operation&#65292;&#20351;&#24471;&#19981;&#34987;&#22238;&#25910;&#10;    @synchronized (self.runningOperations) &#123;&#10;        [self.runningOperations addObject:operation];&#10;    &#125;&#10;    &#10;    NSString *key = [self cacheKeyForURL:url];&#10;&#10;    //cacheOperation&#30340;&#21807;&#19968;&#20215;&#20540;&#26159;&#29992;&#20110;&#24310;&#32531;&#35835;&#21462;&#30913;&#30424;&#30340;&#25805;&#20316;&#65292;&#24182;&#19988;&#25903;&#25345;&#21462;&#28040;&#25805;&#20316;&#10;    operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) &#123;&#10;        if (operation.isCancelled) &#123;&#10;            @synchronized (self.runningOperations) &#123;&#10;                [self.runningOperations removeObject:operation];&#10;            &#125;&#10;&#10;            return;&#10;        &#125;&#10;&#10;        if ((!image || options &#38; SDWebImageRefreshCached) &#38;&#38; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url])) &#123;&#10;            if (image &#38;&#38; options &#38; SDWebImageRefreshCached) &#123;&#10;                dispatch_main_sync_safe(^&#123;&#10;                    &#10;                    //&#34429;&#28982;&#32531;&#23384;&#20102;&#22270;&#29255;&#65292;&#20294;option&#20013;&#25351;&#26126;&#20102;&#35201;&#26356;&#26032;&#32531;&#23384;&#65292;&#25152;&#20197;&#37325;&#26032;&#19979;&#36733;&#10;                    completedBlock(image, nil, cacheType, YES, url);&#10;                &#125;);&#10;            &#125;&#10;&#10;            //&#24320;&#22987;&#19979;&#36733;&#20934;&#22791;&#65292;&#19979;&#36733;&#25805;&#20316;&#20132;&#30001;&#19968;&#20010;SDWebImageDownloaderOperation&#26469;&#23436;&#25104;&#65292;&#24182;&#19988;Manager&#21482;&#38656;&#35201;&#36127;&#36131;&#20182;&#30340;&#21462;&#28040;&#25805;&#20316;&#21363;&#21487;&#10;            //&#25152;&#20197;&#29992;&#19968;&#20010;id&#60;SDWebImageOperation&#62;&#26469;&#24341;&#29992;&#12290;&#10;            SDWebImageDownloaderOptions downloaderOptions = 0;&#10;            if (options &#38; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;&#10;            if (options &#38; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload;&#10;            if (options &#38; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache;&#10;            if (options &#38; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;&#10;            if (options &#38; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;&#10;            if (options &#38; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;&#10;            if (options &#38; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;&#10;            if (image &#38;&#38; options &#38; SDWebImageRefreshCached) &#123;&#10;                // force progressive off if image already cached but forced refreshing&#10;                downloaderOptions &#38;= ~SDWebImageDownloaderProgressiveDownload;&#10;                // ignore image read from NSURLCache if image if cached but force refreshing&#10;                downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;&#10;            &#125;&#10;            //&#37197;&#32622;&#23436;&#30456;&#20851;&#21442;&#25968;&#65292;&#35843;&#29992;imageDownloader&#26469;&#21019;&#24314;&#19979;&#36733;&#25805;&#20316;&#10;            //&#24863;&#35273;SD&#24403;&#20013;&#31649;&#29702;&#23618;&#27425;&#29305;&#21035;&#20998;&#26126;&#65292;&#25972;&#20307;&#30001;Manager&#31649;&#29702;&#65292;&#32531;&#23384;&#30001;SDImageCache&#26469;&#31649;&#29702;&#65292;&#19979;&#36733;&#30001;SDWebImageDownloader&#26469;&#31649;&#29702;&#10;            //&#20855;&#20307;&#25191;&#34892;&#30001;&#20855;&#20307;&#30340;Operation&#26469;&#23436;&#25104;&#65292;&#21313;&#20998;&#28165;&#26224;&#12290;&#10;            id &#60;SDWebImageOperation&#62; subOperation = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished) &#123;&#10;                __strong __typeof(weakOperation) strongOperation = weakOperation;&#10;                if (!strongOperation || strongOperation.isCancelled) &#123;&#10;                    &#10;                    //&#24403;&#25805;&#20316;&#24050;&#32463;&#34987;&#21462;&#28040;&#65292;&#25110;&#32773;&#25805;&#20316;&#24050;&#32463;&#34987;&#38144;&#27585;&#20102;&#65292;&#20854;&#23454;&#23601;&#20195;&#34920;&#36825;&#20010;&#25805;&#20316;&#36807;&#26399;&#20102;&#65292;&#33258;&#28982;&#19981;&#20570;&#20219;&#20309;&#22788;&#29702;&#10;                &#125;&#10;                else if (error) &#123;&#10;                    &#10;                    //&#20135;&#29983;&#20102;&#38169;&#35823;&#10;                    dispatch_main_sync_safe(^&#123;&#10;                        if (strongOperation &#38;&#38; !strongOperation.isCancelled) &#123;&#10;                            completedBlock(nil, error, SDImageCacheTypeNone, finished, url);&#10;                        &#125;&#10;                    &#125;);&#10;&#10;                    if (   error.code != NSURLErrorNotConnectedToInternet&#10;                        &#38;&#38; error.code != NSURLErrorCancelled&#10;                        &#38;&#38; error.code != NSURLErrorTimedOut&#10;                        &#38;&#38; error.code != NSURLErrorInternationalRoamingOff&#10;                        &#38;&#38; error.code != NSURLErrorDataNotAllowed&#10;                        &#38;&#38; error.code != NSURLErrorCannotFindHost&#10;                        &#38;&#38; error.code != NSURLErrorCannotConnectToHost) &#123;&#10;                        @synchronized (self.failedURLs) &#123;&#10;                            [self.failedURLs addObject:url];&#10;                            //&#22914;&#26524;&#19981;&#26159;&#30001;&#20110;&#26381;&#21153;&#22120;&#12289;&#32593;&#32476;&#12289;&#26435;&#38480;&#31561;&#21407;&#22240;&#30340;&#35805;&#65292;&#36825;&#20010;&#38142;&#25509;&#23601;&#26159;&#19968;&#20010;&#22833;&#36133;&#30340;&#38142;&#25509;&#10;                        &#125;&#10;                    &#125;&#10;                &#125;&#10;                else &#123;&#10;                    if ((options &#38; SDWebImageRetryFailed)) &#123;&#10;                        @synchronized (self.failedURLs) &#123;&#10;                            [self.failedURLs removeObject:url];&#10;                        &#125;&#10;                        //&#37325;&#26032;&#35831;&#27714;&#27491;&#24120;&#30340;&#35805;&#65292;&#21017;&#23558;&#22833;&#36133;&#38142;&#25509;&#31227;&#38500;&#10;                    &#125;&#10;                    &#10;                    BOOL cacheOnDisk = !(options &#38; SDWebImageCacheMemoryOnly);&#10;&#10;                    if (options &#38; SDWebImageRefreshCached &#38;&#38; image &#38;&#38; !downloadedImage) &#123;&#10;                        //&#36825;&#20010;&#22320;&#26041;&#26412;&#24212;&#35813;&#35843;&#29992;&#22238;&#35843;&#38381;&#21253;&#65292;&#20294;&#21487;&#20197;&#21457;&#29616;&#65292;&#22312;&#19978;&#38754;&#24050;&#32463;&#35843;&#29992;&#36807;&#20102;&#10;                    &#125;&#10;                    else if (downloadedImage &#38;&#38; (!downloadedImage.images || (options &#38; SDWebImageTransformAnimatedImage)) &#38;&#38; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) &#123;&#10;                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;&#10;                            //&#36825;&#20010;&#20063;&#19981;&#26159;&#24456;&#25026;&#65292;&#35843;&#29992;&#20195;&#29702;&#26041;&#27861;&#65292;&#23545;&#22270;&#29255;&#36827;&#34892;&#24322;&#27493;&#22788;&#29702;&#10;                            UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];&#10;&#10;                            if (transformedImage &#38;&#38; finished) &#123;&#10;                                BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];&#10;                                //&#23558;&#19979;&#36733;&#30340;&#22270;&#29255;&#23384;&#21040;disk&#21644;memory&#24403;&#20013;&#10;                                //&#20854;&#20013;&#30340;data&#65292;&#22914;&#26524;&#26159;&#22270;&#29255;&#24050;&#32463;&#34987;&#20462;&#25913;&#20102;&#65292;&#37027;&#20040;&#26159;&#20256;nil&#65292;&#23558;&#22312;&#26041;&#27861;&#20869;&#37325;&#26032;&#29983;&#25104;&#19968;&#20010;&#36866;&#21512;&#23384;&#20648;&#30340;data&#10;                                [self.imageCache storeImage:transformedImage recalculateFromImage:imageWasTransformed imageData:(imageWasTransformed ? nil : data) forKey:key toDisk:cacheOnDisk];&#10;                            &#125;&#10;                            &#10;                            //&#22914;&#26524;&#26041;&#27861;&#27809;&#26377;&#34987;&#21462;&#28040;&#65292;&#21017;&#27491;&#24120;&#35843;&#29992;&#22238;&#35843;&#10;                            dispatch_main_sync_safe(^&#123;&#10;                                if (strongOperation &#38;&#38; !strongOperation.isCancelled) &#123;&#10;                                    completedBlock(transformedImage, nil, SDImageCacheTypeNone, finished, url);&#10;                                &#125;&#10;                            &#125;);&#10;                        &#125;);&#10;                    &#125;&#10;                    else &#123;&#10;                        //&#23384;&#20648;&#21152;&#22238;&#35843;&#65292;&#27492;&#22788;&#19981;&#38656;&#35201;&#23545;&#22270;&#29255;&#36827;&#34892;&#39069;&#22806;&#30340;&#22788;&#29702;&#10;                        if (downloadedImage &#38;&#38; finished) &#123;&#10;                            [self.imageCache storeImage:downloadedImage recalculateFromImage:NO imageData:data forKey:key toDisk:cacheOnDisk];&#10;                        &#125;&#10;&#10;                        dispatch_main_sync_safe(^&#123;&#10;                            if (strongOperation &#38;&#38; !strongOperation.isCancelled) &#123;&#10;                                completedBlock(downloadedImage, nil, SDImageCacheTypeNone, finished, url);&#10;                            &#125;&#10;                        &#125;);&#10;                    &#125;&#10;                &#125;&#10;                //&#25805;&#20316;&#32467;&#26463;&#23601;&#23558;Operation&#31227;&#38500;&#10;                if (finished) &#123;&#10;                    @synchronized (self.runningOperations) &#123;&#10;                        if (strongOperation) &#123;&#10;                            [self.runningOperations removeObject:strongOperation];&#10;                        &#125;&#10;                    &#125;&#10;                &#125;&#10;            &#125;];&#10;            &#10;            //&#37197;&#32622;Operation&#30340;&#21462;&#28040;&#22238;&#35843;&#10;            operation.cancelBlock = ^&#123;&#10;                [subOperation cancel];&#10;                &#10;                @synchronized (self.runningOperations) &#123;&#10;                    __strong __typeof(weakOperation) strongOperation = weakOperation;&#10;                    if (strongOperation) &#123;&#10;                        [self.runningOperations removeObject:strongOperation];&#10;                    &#125;&#10;                &#125;&#10;            &#125;;&#10;        &#125;&#10;        else if (image) &#123;&#10;            //&#32531;&#23384;&#24403;&#20013;&#26377;&#22270;&#29255;&#65292;&#32780;&#19988;&#19981;&#38656;&#35201;&#36827;&#34892;&#19979;&#36733;&#30340;&#24773;&#20917;&#19979;&#25191;&#34892;&#10;            dispatch_main_sync_safe(^&#123;&#10;                __strong __typeof(weakOperation) strongOperation = weakOperation;&#10;                if (strongOperation &#38;&#38; !strongOperation.isCancelled) &#123;&#10;                    completedBlock(image, nil, cacheType, YES, url);&#10;                &#125;&#10;            &#125;);&#10;            @synchronized (self.runningOperations) &#123;&#10;                [self.runningOperations removeObject:operation];&#10;            &#125;&#10;        &#125;&#10;        else &#123;&#10;            //&#32531;&#23384;&#24403;&#20013;&#27809;&#26377;&#22270;&#29255;&#65292;&#32780;&#19988;&#19979;&#36733;&#25805;&#20316;&#20063;&#19981;&#33021;&#36827;&#34892;&#30340;&#24773;&#20917;&#19979;&#10;            dispatch_main_sync_safe(^&#123;&#10;                __strong __typeof(weakOperation) strongOperation = weakOperation;&#10;                if (strongOperation &#38;&#38; !weakOperation.isCancelled) &#123;&#10;                    completedBlock(nil, nil, SDImageCacheTypeNone, YES, url);&#10;                &#125;&#10;            &#125;);&#10;            @synchronized (self.runningOperations) &#123;&#10;                [self.runningOperations removeObject:operation];&#10;            &#125;&#10;        &#125;&#10;    &#125;];&#10;&#10;    return operation;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>整个方法看下来，我看的最多的就是Operation判断取消的操作，对于已经取消的操作，则该方法将不再被runningpertaion，将会被系统回收，具体回收时间还得看runLoop，所以单单看有无回收是不准确的，还要借助_isCancelled，就能确定Operation是否真的不需要执行了。</p>
<h4 id="SDImageCache"><a href="#SDImageCache" class="headerlink" title="SDImageCache"></a>SDImageCache</h4><p>接下来我们先看一下缓存操作，这边还是挺简单的。<br>SD使用的是对<code>NSCache</code>的封装，当接收到<code>Memory Warning</code>的时候，将缓存清空。读取的时候也是先向内存读取，再向磁盘读取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#20174;&#32531;&#23384;&#24403;&#20013;&#33719;&#24471;&#22270;&#29255;&#30340;&#26041;&#27861;&#10;- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock &#123;&#10;    //&#20808;&#20570;&#19968;&#20123;&#21028;&#26029;&#10;    if (!doneBlock) &#123;&#10;        return nil;&#10;    &#125;&#10;&#10;    if (!key) &#123;&#10;        doneBlock(nil, SDImageCacheTypeNone);&#10;        return nil;&#10;    &#125;&#10;&#10;    //&#19968;&#33324;&#20197;url&#20316;&#20026;&#38190;&#20540;&#65292;&#20808;&#21521;&#20869;&#23384;&#21462;&#10;    UIImage *image = [self imageFromMemoryCacheForKey:key];&#10;    if (image) &#123;&#10;        doneBlock(image, SDImageCacheTypeMemory);&#10;        return nil;&#10;    &#125;&#10;&#10;    //&#21019;&#24314;&#19968;&#20010;&#25805;&#20316;&#65292;&#22312;&#20018;&#34892;&#38431;&#21015;&#24403;&#20013;&#21521;&#30913;&#30424;&#35835;&#21462;&#32531;&#23384;&#65292;&#24182;&#19988;&#20351;&#24471;&#25805;&#20316;&#25903;&#25345;&#21462;&#28040;&#30340;&#21151;&#33021;&#10;    //&#19981;&#30693;&#36947;&#36825;&#37324;&#29992;&#25805;&#20316;&#38500;&#20102;&#36825;&#26679;&#36824;&#26377;&#20160;&#20040;&#21151;&#33021;&#65311;&#22914;&#26524;&#21482;&#26159;&#20026;&#20102;&#19968;&#20010;bool&#20540;&#65292;&#29992;&#26222;&#36890;&#21464;&#37327;&#19981;&#26159;&#26356;&#22909;&#10;    NSOperation *operation = [NSOperation new];&#10;    dispatch_async(self.ioQueue, ^&#123;&#10;        //&#21028;&#26029;&#26159;&#21542;&#24050;&#32463;&#34987;&#21462;&#28040;&#20102;&#65288;&#36825;&#36793;&#26159;&#21152;&#22312;&#19968;&#20010;&#20018;&#34892;&#38431;&#21015;&#24403;&#20013;&#65292;&#25152;&#20197;&#19981;&#19968;&#23450;&#39532;&#19978;&#25191;&#34892;&#65289;&#10;        if (operation.isCancelled) &#123;&#10;            return;&#10;        &#125;&#10;        //&#21033;&#29992;&#19968;&#20010;autoreleasepool&#65292;&#23601;&#21487;&#20197;&#21450;&#26102;&#37322;&#25918;&#20869;&#23384;&#10;        @autoreleasepool &#123;&#10;            //&#21521;&#30913;&#30424;&#35835;&#21462;&#32531;&#23384;&#10;            UIImage *diskImage = [self diskImageForKey:key];&#10;            //&#33509;&#38656;&#21017;&#23558;&#22270;&#29255;&#21152;&#20837;&#20869;&#23384;&#32531;&#23384;&#65292;&#21542;&#21017;&#22312;pool&#32467;&#26463;&#21518;&#65292;&#23558;&#34987;&#31995;&#32479;&#22238;&#25910;&#10;            if (diskImage &#38;&#38; self.shouldCacheImagesInMemory) &#123;&#10;                NSUInteger cost = SDCacheCostForImage(diskImage);&#10;                [self.memCache setObject:diskImage forKey:key cost:cost];&#10;            &#125;&#10;            &#10;            dispatch_async(dispatch_get_main_queue(), ^&#123;&#10;                doneBlock(diskImage, SDImageCacheTypeDisk);&#10;            &#125;);&#10;        &#125;&#10;    &#125;);&#10;&#10;    return operation;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>SD的缓存是对<code>NSCache</code>的封装，对于存入disk的图片，其路径会通过<code>MD5</code>进行加密</p>
<h4 id="SDWebImageDownloader"><a href="#SDWebImageDownloader" class="headerlink" title="SDWebImageDownloader"></a>SDWebImageDownloader</h4><p><code>SDWebImageDownloader</code>是SD当中负责对下载进行统一管理的类，通过持有一个<code>NSOperationQueue</code>对所有的<code>DownloaderOperation</code>进行管理，并且可以设置队列的进出策略是<code>FIFO</code>还是<code>LIFO</code>。并持有一个<code>NSURLSession</code>管理着所有的连接操作，当收到回调的时候调用<code>DownloaderOperation</code>相应的代理方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#22312;&#35813;&#26041;&#27861;&#24403;&#20013;&#65292;&#21019;&#24314;&#20102;&#19968;&#20010;DownloadOperation&#23545;&#35937;&#65292;&#24182;&#21152;&#20837;&#19979;&#36733;&#38431;&#21015;DownloaderQueue&#36827;&#34892;&#19979;&#36733;&#12290;&#10;- (id &#60;SDWebImageOperation&#62;)downloadImageWithURL:(NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock &#123;&#10;    __block SDWebImageDownloaderOperation *operation;&#10;    __weak __typeof(self)wself = self;&#10;&#10;    //&#36319;progress&#19968;&#36215;&#21019;&#24314;&#10;    [self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^&#123;&#10;        NSTimeInterval timeoutInterval = wself.downloadTimeout;&#10;        if (timeoutInterval == 0.0) &#123;&#10;            timeoutInterval = 15.0;&#10;        &#125;&#10;&#10;        // In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise&#10;        //&#36825;&#36793;&#30340;&#24847;&#24605;&#24212;&#35813;&#26159;&#25105;&#20204;&#26412;&#22320;&#24050;&#32463;&#26377;&#32531;&#23384;&#25805;&#20316;&#20102;&#65292;&#25152;&#20197;&#25105;&#20204;&#36873;&#25321;&#30452;&#25509;&#19979;&#36733;&#10;        NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:(options &#38; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData) timeoutInterval:timeoutInterval];&#10;        request.HTTPShouldHandleCookies = (options &#38; SDWebImageDownloaderHandleCookies);&#10;        request.HTTPShouldUsePipelining = YES;&#10;        if (wself.headersFilter) &#123;&#10;            request.allHTTPHeaderFields = wself.headersFilter(url, [wself.HTTPHeaders copy]);&#10;        &#125;&#10;        else &#123;&#10;            request.allHTTPHeaderFields = wself.HTTPHeaders;&#10;        &#125;&#10;        //&#21019;&#24314;&#19968;&#20010;DownloaderOperation&#10;        operation = [[wself.operationClass alloc] initWithRequest:request&#10;                                                        inSession:self.session&#10;                                                          options:options&#10;                                                //progress&#22238;&#35843;&#10;                                                         progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123;&#10;                                                             SDWebImageDownloader *sself = wself;&#10;                                                             if (!sself) return;&#10;                                                             __block NSArray *callbacksForURL;&#10;                                                             dispatch_sync(sself.barrierQueue, ^&#123;&#10;                                                                 callbacksForURL = [sself.URLCallbacks[url] copy];&#10;                                                             &#125;);&#10;                                                             for (NSDictionary *callbacks in callbacksForURL) &#123;&#10;                                                                 dispatch_async(dispatch_get_main_queue(), ^&#123;&#10;                                                                     SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];&#10;                                                                     if (callback) callback(receivedSize, expectedSize);&#10;                                                                 &#125;);&#10;                                                             &#125;&#10;                                                         &#125;&#10;                                                 //&#19979;&#36733;&#23436;&#25104;&#22238;&#35843;&#10;                                                        completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) &#123;&#10;                                                            SDWebImageDownloader *sself = wself;&#10;                                                            if (!sself) return;&#10;                                                            __block NSArray *callbacksForURL;&#10;                                                //&#36825;&#36793;&#20026;&#20102;&#20445;&#35777;&#32447;&#31243;&#23433;&#20840;&#65292;&#29992;&#20102;barrier_sync&#10;                                                            dispatch_barrier_sync(sself.barrierQueue, ^&#123;&#10;                                                                callbacksForURL = [sself.URLCallbacks[url] copy];&#10;                                                                if (finished) &#123;&#10;                                                                    [sself.URLCallbacks removeObjectForKey:url];&#10;                                                                &#125;&#10;                                                            &#125;);&#10;                                                            for (NSDictionary *callbacks in callbacksForURL) &#123;&#10;                                                                SDWebImageDownloaderCompletedBlock callback = callbacks[kCompletedCallbackKey];&#10;                                                                if (callback) callback(image, data, error, finished);&#10;                                                            &#125;&#10;                                                        &#125;&#10;                                                 //&#21462;&#28040;&#22238;&#35843;&#10;                                                        cancelled:^&#123;&#10;                                                            SDWebImageDownloader *sself = wself;&#10;                                                            if (!sself) return;&#10;                                                            dispatch_barrier_async(sself.barrierQueue, ^&#123;&#10;                                                                [sself.URLCallbacks removeObjectForKey:url];&#10;                                                            &#125;);&#10;                                                        &#125;];&#10;        //&#23545;&#22270;&#29255;&#36827;&#34892;&#22788;&#29702;&#30340;&#26631;&#35782;&#65292;&#36824;&#19981;&#26159;&#24456;&#25026;&#10;        operation.shouldDecompressImages = wself.shouldDecompressImages;&#10;        &#10;        if (wself.urlCredential) &#123;&#10;            operation.credential = wself.urlCredential;&#10;        &#125; else if (wself.username &#38;&#38; wself.password) &#123;&#10;            operation.credential = [NSURLCredential credentialWithUser:wself.username password:wself.password persistence:NSURLCredentialPersistenceForSession];&#10;        &#125;&#10;        &#10;        if (options &#38; SDWebImageDownloaderHighPriority) &#123;&#10;            operation.queuePriority = NSOperationQueuePriorityHigh;&#10;        &#125; else if (options &#38; SDWebImageDownloaderLowPriority) &#123;&#10;            operation.queuePriority = NSOperationQueuePriorityLow;&#10;        &#125;&#10;        //&#21152;&#20837;&#21040;&#19979;&#36733;&#38431;&#21015;&#65292;&#30452;&#21040;&#36825;&#37324;&#65292;&#25165;&#31639;&#20934;&#22791;&#24320;&#22987;&#19979;&#36733;&#22270;&#29255;&#10;        [wself.downloadQueue addOperation:operation];&#10;        //&#35774;&#32622;&#38431;&#21015;&#30340;&#25191;&#34892;&#39034;&#24207;&#10;        if (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;&#10;            [wself.lastAddedOperation addDependency:operation];&#10;            wself.lastAddedOperation = operation;&#10;        &#125;&#10;    &#125;];&#10;&#10;    return operation;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SDWebImageDownloaderOperation"><a href="#SDWebImageDownloaderOperation" class="headerlink" title="SDWebImageDownloaderOperation"></a>SDWebImageDownloaderOperation</h4><p>　　这个类是<code>NSOperation</code>的一个子类，并重写了<code>-start</code>方法，在自定义<code>NSOperation</code>子类的时候，当Operation时并发操作的时候，就需要自己重写<code>Executing</code>、<code>Finish</code>、<code>asynchronous</code>三个属性，因为系统没办法判断何时完成。<br>　　SD的下载操作都是对<code>NSURLSession</code>的封装。而且在start方法也比较简单，创建一个dataTask和注册后台任务。</p>
<h4 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h4><p>　　第一次对<code>SDWebImage</code>的学习就到这里了。也只是简单的对源码的阅读，希望是一个开始，等我有了稳定工作之后，再来后续的学习吧。最近还在准备校招的过程当中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;SDWebImage&quot;&gt;&lt;a href=&quot;#SDWebImage&quot; class=&quot;headerlink&quot; title=&quot;SDWebImage&quot;&gt;&lt;/a&gt;SDWebImage&lt;/h4&gt;&lt;p&gt;　　之前一直在打算看SDWebImage的源码，一方面是因为面试常问，一方面
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网易面试体会</title>
    <link href="https://jasoniosdev.github.io/NetEaseOfferTry/"/>
    <id>https://jasoniosdev.github.io/NetEaseOfferTry/</id>
    <published>2016-08-19T15:44:00.000Z</published>
    <updated>2016-08-24T10:28:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　总的一个体会来讲，应该是感谢，感谢网易能够给予自己面试的机会。<br>　　虽然没能够拿到Offer，但自己也是当做一次学习吧，认识自己的一次经历。<br><a id="more"></a><br>　　说到面试，也可以说是自己大三所做的一个比较不足，略有遗憾的事情，因为自身的无知，以及身边资源相对的欠缺，所以导致在春招进行的热闹非凡的情况下，自己却全然无动于衷，只把心思放在秋招上，这也是自己一直以来做事的一个缺点，总是喜欢被动的去了解一些事物，除非是最后时刻。所以自己因此也错过了春招这一次十分好的锻炼自己的机会。<br>　　回到秋招，原本之前我是打算继续读研究生的，虽然自己对于研究生这东西没什么兴趣，因为自己对于开发实在是太过热爱，所以在一开始的时候是抱着工作一半，研究生一半的心思得过且过。寻思着到时候能够保研，毕竟那时候还天真的认为自己是多么的优秀，能够拿到学校的保研名额，能够成功的被高校所吸收，在后来的时候受挫了，看着自己差劲的成绩，只有勉强一点竞赛成绩还看着过去。不过并没什么卵用。<br>　　对于面试，网易其实是我参加面试的第二个公司，第一个参与面试的公司是阿里，那时候在网上得到内推资格后，在第二周就收到了阿里一面的电话，那时候心情十分的激动，以至于说话十分的跳，不过由于来的实在太早，加上自己并没有什么经验，对于所问的东西心里都没底，所以就那样没有了然后。<br>　　网易今年是放宽了要求，只需要内推，就都有机会参与笔试，成功通过就可以进入面试环节，还给报销来回车费，简直良心。<br>　　在面试当天发生了一件有趣的事情，我出门的时候居然忘记吃饭了（看来是太紧张了）。到了网易，坐下之后，听到工作人员在问早上面试的同学要不要吃饭的时候，自己才发觉，原来自己还没有吃饭。但自己又怕跟着去，会被认出来。来回转了几圈，最终还是跟去吃饭了。网易餐厅吃饭果然是免费的，而且伙食条件上层，吃饭的时候就在想，要是自己未来能够在那环境下工作，该有多好。<br>　　下午面试开始了，我是13点面试，不过由于早上面试的延迟，到了13点40分左右，才叫到我去面试。一面的面试官是一个年轻的小伙子，十分的nice，他问了我几个iOS的问题，还有算法，还有关于项目上的问题。除了两个问题不会之外，都答出来了。什么时候需要手动加自动释放池以及沙盒机制。这两个问题没能够答上来。在后面面试官也问了一个我十分喜欢的问题，就是我做算法而选择开发。我也向面试官表达了我喜欢做产品的想法，最后他也表示认同的说：我也看出来你喜欢做产品了。<br>　　过了十几分钟，上了个厕所回来，就轮到我二面了，面试官没有问项目上的问题，而是直接问关于RunLoop，还好自己RunLoop前后看了好几遍，虽然还有一些小问题还不清楚，但答的还可以。后来面试官又问了我如何实现自定义动画以及模态如何实现像导航栏返回的手势，幸好自己在之前做的《田园智慧管家》有尝试封装过自定义转场，所以也是答上来了，然后还问了关于第三方库源码，以及SDWebImage网络请求是用哪个库实现的，自己在之前也是专门看了SDWebImage的源码，虽然还没看完，打算继续研究，所以也是记得。<br>　　总的来说，两轮技术面还挺顺利，都问到了自己所准备的问题。在后来去问的时候，得知说还要进行总监面，那时候不知道总监面是什么东西，有点疑惑，不过在叫到我的时候，直接就是HR面了。在回去的时候才知道原来能够总监面的人都是表现比较好的，自己的没能总监面，应该是不够优秀吧。<br>　　总的面试下来，主要是HR那块表现的不是很好，自己在心情的把握上比较不好，跟HR虽然聊了很久，但最后HR也是突然结束。所以应该是没什么希望了。<br>　　不过这次面试想下来，自己还做的不够的地方应该是自己会答，但答的不够好，答得不够全。所以在之后假如还有机会面试的话，自己需要慢一点，将问题答得更为令人满意，不过这还需要过硬的心里素质。<br>　　在之后自己也希望能够开始自己的iOS博客，将技术和生活小记下来。此篇做为第一篇。END！<br>　　<br>　　今天才发现，为什么自己当初被取消了总监面的机会，说起来也可笑。原来在一面的时候，面试官问了我一个关于迪杰斯特拉算法的问题，我回答的很好，然后我自己多答了prim算法，然后把迪杰斯特拉算法当成了克鲁斯卡尔算法，进行了两者的比较，没错，就是问最小路径算法，最后自己补了个最小生成树算法，并且把原来的混为一谈了。想必是后来面试官把我的评分从A改为了C吧，所以所谓的总监面也就没了，太可惜了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　总的一个体会来讲，应该是感谢，感谢网易能够给予自己面试的机会。&lt;br&gt;　　虽然没能够拿到Offer，但自己也是当做一次学习吧，认识自己的一次经历。&lt;br&gt;
    
    </summary>
    
      <category term="生活小记" scheme="https://jasoniosdev.github.io/categories/%E7%94%9F%E6%B4%BB%E5%B0%8F%E8%AE%B0/"/>
    
    
      <category term="大三" scheme="https://jasoniosdev.github.io/tags/%E5%A4%A7%E4%B8%89/"/>
    
      <category term="面试" scheme="https://jasoniosdev.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
